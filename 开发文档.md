# DTD(DrawTrainData) 开发文档

## 1. 项目初始化

### 1.1 创建项目目录
```bash
mkdir DrawTrainData
cd DrawTrainData
```

### 1.2 创建基础文件
- index.html - 主页面
- styles.css - 样式文件
- script.js - 主脚本文件
- README.md - 项目说明

### 1.3 引入第三方库
在HTML文件中引入所需的第三方库：
- JSZip - 用于文件压缩
- FileSaver.js - 用于文件下载

## 2. 目录结构
```
DrawTrainData/
├── index.html          # 主页面
├── styles.css          # 样式文件
├── script.js           # 主脚本文件
├── lib/
│   ├── jszip.min.js    # JSZip库
│   └── FileSaver.min.js # FileSaver库
└── README.md           # 项目说明
```

## 3. HTML结构设计

### 3.1 页面框架
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DTD - DrawTrainData</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>DTD - DrawTrainData</h1>
        </header>
        
        <main>
            <!-- 尺寸选择区 -->
            <section class="size-selection">
                <!-- 尺寸选择控件 -->
            </section>
            
            <!-- 画板区 -->
            <section class="canvas-area">
                <canvas id="drawingCanvas"></canvas>
            </section>
            
            <!-- 操作控制区 -->
            <section class="controls">
                <!-- 保存、重置按钮 -->
            </section>
            
            <!-- 图片夹区 -->
            <section class="image-gallery">
                <!-- 图片列表 -->
            </section>
            
            <!-- 导出区 -->
            <section class="export-section">
                <!-- 导出选项 -->
            </section>
        </main>
    </div>
    
    <!-- 引入第三方库 -->
    <script src="lib/jszip.min.js"></script>
    <script src="lib/FileSaver.min.js"></script>
    <script src="script.js"></script>
</body>
</html>
```

### 3.2 尺寸选择区详细设计
```html
<div class="size-selection">
    <label for="sizeSelect">选择尺寸：</label>
    <select id="sizeSelect">
        <option value="16x16">16×16</option>
        <option value="32x32">32×32</option>
        <option value="64x64">64×64</option>
        <option value="128x128">128×128</option>
        <option value="custom">自定义</option>
    </select>
    
    <div id="customSize" style="display: none;">
        <label for="widthInput">宽度：</label>
        <input type="number" id="widthInput" min="1" value="16">
        <label for="heightInput">高度：</label>
        <input type="number" id="heightInput" min="1" value="16">
        <button id="applySizeBtn">应用</button>
    </div>
</div>
```

### 3.3 操作控制区详细设计
```html
<div class="controls">
    <button id="saveBtn">保存到图片夹</button>
    <button id="resetBtn">重置画板</button>
    <button id="clearGalleryBtn">重置图片夹</button>
</div>
```

### 3.4 图片夹区详细设计
```html
<div class="image-gallery">
    <h3>图片夹 <span id="imageCount">0</span> 张</h3>
    <div id="galleryContainer"></div>
</div>
```

### 3.5 导出区详细设计
```html
<div class="export-section">
    <h3>导出数据集</h3>
    <div class="export-options">
        <label>
            <input type="radio" name="exportFormat" value="bmp" checked> BMP格式
        </label>
        <label>
            <input type="radio" name="exportFormat" value="txt"> TXT格式
        </label>
    </div>
    <button id="exportBtn">导出数据集</button>
</div>
```

## 4. CSS样式设计

### 4.1 全局样式
```css
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #f5f5f5;
    color: #333;
    line-height: 1.6;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

header {
    text-align: center;
    margin-bottom: 30px;
}

main {
    display: flex;
    flex-direction: column;
    gap: 20px;
}
```

### 4.2 尺寸选择区样式
```css
.size-selection {
    display: flex;
    align-items: center;
    gap: 15px;
    background-color: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.size-selection label {
    font-weight: bold;
}

.size-selection select, .size-selection input {
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
}

#applySizeBtn {
    padding: 8px 15px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

#applySizeBtn:hover {
    background-color: #45a049;
}
```

### 4.3 画板区样式
```css
.canvas-area {
    display: flex;
    justify-content: center;
    background-color: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

#drawingCanvas {
    border: 1px solid #ddd;
    background-color: white;
    cursor: crosshair;
}
```

### 4.4 操作控制区样式
```css
.controls {
    display: flex;
    gap: 15px;
    justify-content: center;
}

.controls button {
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
}

#saveBtn {
    background-color: #4CAF50;
    color: white;
}

#resetBtn {
    background-color: #f44336;
    color: white;
}

#clearGalleryBtn {
    background-color: #2196F3;
    color: white;
}

.controls button:hover {
    opacity: 0.9;
}
```

### 4.5 图片夹区样式
```css
.image-gallery {
    background-color: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.image-gallery h3 {
    margin-bottom: 15px;
}

#galleryContainer {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    max-height: 200px;
    overflow-y: auto;
}

.gallery-item {
    width: 80px;
    height: 80px;
    border: 1px solid #ddd;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: white;
}

.gallery-item canvas {
    max-width: 100%;
    max-height: 100%;
}
```

### 4.6 导出区样式
```css
.export-section {
    background-color: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    text-align: center;
}

.export-section h3 {
    margin-bottom: 15px;
}

.export-options {
    margin-bottom: 15px;
    display: flex;
    justify-content: center;
    gap: 20px;
}

#exportBtn {
    padding: 10px 20px;
    background-color: #9C27B0;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
}

#exportBtn:hover {
    background-color: #7B1FA2;
}
```

## 5. JavaScript功能实现

### 5.1 核心数据结构
```javascript
// 应用状态
const appState = {
    currentImageSize: { width: 32, height: 32 },
    isDrawing: false,
    currentCanvas: null,
    imageGallery: [],
    cellSize: 0
};

// 本地存储键名
const STORAGE_KEY = 'dtd-workspace';
```

### 5.2 初始化函数
```javascript
function init() {
    // 加载本地存储数据
    loadFromStorage();
    
    // 初始化Canvas
    initCanvas();
    
    // 绑定事件监听器
    bindEventListeners();
    
    // 渲染图片夹
    renderGallery();
}

// 页面加载完成后初始化
document.addEventListener('DOMContentLoaded', init);
```

### 5.3 Canvas初始化
```javascript
function initCanvas() {
    const canvas = document.getElementById('drawingCanvas');
    const ctx = canvas.getContext('2d');
    
    // 设置Canvas大小
    const maxCanvasSize = 600;
    const { width, height } = appState.currentImageSize;
    
    // 计算单元格大小
    appState.cellSize = Math.min(
        Math.floor(maxCanvasSize / width),
        Math.floor(maxCanvasSize / height)
    );
    
    // 设置Canvas实际尺寸
    canvas.width = width * appState.cellSize;
    canvas.height = height * appState.cellSize;
    
    // 绘制网格
    drawGrid(ctx);
    
    // 初始化空白图像数据
    appState.currentCanvas = createEmptyCanvas(width, height);
}
```

### 5.4 事件监听器绑定
```javascript
function bindEventListeners() {
    // 尺寸选择事件
    document.getElementById('sizeSelect').addEventListener('change', handleSizeChange);
    document.getElementById('applySizeBtn').addEventListener('click', applyCustomSize);
    
    // Canvas事件
    const canvas = document.getElementById('drawingCanvas');
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('mouseleave', handleMouseUp);
    
    // 控制按钮事件
    document.getElementById('saveBtn').addEventListener('click', saveToGallery);
    document.getElementById('resetBtn').addEventListener('click', resetCanvas);
    document.getElementById('clearGalleryBtn').addEventListener('click', clearGallery);
    
    // 导出事件
    document.getElementById('exportBtn').addEventListener('click', exportDataset);
}
```

### 5.5 绘制功能实现
```javascript
function handleMouseDown(e) {
    appState.isDrawing = true;
    drawCell(e);
}

function handleMouseMove(e) {
    if (appState.isDrawing) {
        drawCell(e);
    }
}

function handleMouseUp() {
    appState.isDrawing = false;
}

function drawCell(e) {
    const canvas = document.getElementById('drawingCanvas');
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / appState.cellSize);
    const y = Math.floor((e.clientY - rect.top) / appState.cellSize);
    
    // 更新单元格状态
    if (x >= 0 && x < appState.currentImageSize.width && 
        y >= 0 && y < appState.currentImageSize.height) {
        
        appState.currentCanvas[y][x] = 1; // 1表示黑色
        drawSingleCell(x, y);
    }
}
```

### 5.6 图片夹管理
```javascript
function saveToGallery() {
    // 深拷贝当前Canvas数据
    const imageData = JSON.parse(JSON.stringify(appState.currentCanvas));
    
    // 添加到图片夹
    appState.imageGallery.push({
        id: `img_${Date.now()}`,
        data: imageData,
        width: appState.currentImageSize.width,
        height: appState.currentImageSize.height,
        createdAt: new Date().toISOString()
    });
    
    // 保存到本地存储
    saveToStorage();
    
    // 渲染图片夹
    renderGallery();
    
    // 重置当前Canvas
    resetCanvas();
}

function renderGallery() {
    const container = document.getElementById('galleryContainer');
    const count = document.getElementById('imageCount');
    
    // 更新图片数量
    count.textContent = appState.imageGallery.length;
    
    // 清空容器
    container.innerHTML = '';
    
    // 渲染每个图片
    appState.imageGallery.forEach((image, index) => {
        const item = document.createElement('div');
        item.className = 'gallery-item';
        
        // 创建缩略图画布
        const thumbCanvas = document.createElement('canvas');
        thumbCanvas.width = 60;
        thumbCanvas.height = 60;
        const thumbCtx = thumbCanvas.getContext('2d');
        
        // 绘制缩略图
        const thumbCellSize = Math.min(thumbCanvas.width / image.width, thumbCanvas.height / image.height);
        image.data.forEach((row, y) => {
            row.forEach((cell, x) => {
                if (cell === 1) {
                    thumbCtx.fillStyle = 'black';
                    thumbCtx.fillRect(
                        x * thumbCellSize,
                        y * thumbCellSize,
                        thumbCellSize,
                        thumbCellSize
                    );
                }
            });
        });
        
        item.appendChild(thumbCanvas);
        container.appendChild(item);
    });
}
```

### 5.7 本地存储实现
```javascript
function saveToStorage() {
    const data = {
        imageGallery: appState.imageGallery,
        currentImageSize: appState.currentImageSize,
        lastModified: new Date().toISOString()
    };
    
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
}

function loadFromStorage() {
    const storedData = localStorage.getItem(STORAGE_KEY);
    if (storedData) {
        const data = JSON.parse(storedData);
        appState.imageGallery = data.imageGallery || [];
        appState.currentImageSize = data.currentImageSize || { width: 32, height: 32 };
    }
}
```

### 5.8 导出功能实现
```javascript
async function exportDataset() {
    const format = document.querySelector('input[name="exportFormat"]:checked').value;
    const zip = new JSZip();
    
    if (appState.imageGallery.length === 0) {
        alert('图片夹为空，请先绘制图片！');
        return;
    }
    
    // 生成导出文件
    for (let i = 0; i < appState.imageGallery.length; i++) {
        const image = appState.imageGallery[i];
        
        if (format === 'bmp') {
            // 导出为BMP
            const bmpData = await convertToBMP(image);
            zip.file(`image_${i}.bmp`, bmpData);
        } else {
            // 导出为TXT
            const txtContent = JSON.stringify(image.data);
            zip.file(`image_${i}.txt`, txtContent);
        }
    }
    
    // 生成ZIP文件并下载
    const zipContent = await zip.generateAsync({ type: 'blob' });
    const timestamp = new Date().getTime();
    saveAs(zipContent, `dtd-dataset-${timestamp}.zip`);
}
```

### 5.9 辅助函数
```javascript
// 创建空白画布数据
function createEmptyCanvas(width, height) {
    const canvas = [];
    for (let y = 0; y < height; y++) {
        canvas[y] = [];
        for (let x = 0; x < width; x++) {
            canvas[y][x] = 0; // 0表示白色
        }
    }
    return canvas;
}

// 绘制网格
function drawGrid(ctx) {
    const { width, height } = appState.currentImageSize;
    const cellSize = appState.cellSize;
    
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 0.5;
    
    // 绘制垂直线
    for (let x = 0; x <= width; x++) {
        ctx.beginPath();
        ctx.moveTo(x * cellSize, 0);
        ctx.lineTo(x * cellSize, height * cellSize);
        ctx.stroke();
    }
    
    // 绘制水平线
    for (let y = 0; y <= height; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * cellSize);
        ctx.lineTo(width * cellSize, y * cellSize);
        ctx.stroke();
    }
}

// 绘制单个单元格
function drawSingleCell(x, y) {
    const canvas = document.getElementById('drawingCanvas');
    const ctx = canvas.getContext('2d');
    
    ctx.fillStyle = 'black';
    ctx.fillRect(
        x * appState.cellSize,
        y * appState.cellSize,
        appState.cellSize,
        appState.cellSize
    );
    
    // 重绘单元格边框
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 0.5;
    ctx.strokeRect(
        x * appState.cellSize,
        y * appState.cellSize,
        appState.cellSize,
        appState.cellSize
    );
}
```

## 6. 测试与部署

### 6.1 功能测试
- 测试尺寸选择功能
- 测试绘制功能
- 测试保存和重置功能
- 测试图片夹管理
- 测试导出功能
- 测试本地存储功能

### 6.2 兼容性测试
- Chrome浏览器
- Firefox浏览器
- Safari浏览器
- Edge浏览器
- 移动设备浏览器

### 6.3 部署方式
由于DTD是纯前端应用，可以直接部署到任何静态文件服务器：
1. 将所有文件上传到服务器
2. 确保文件路径正确
3. 访问index.html即可使用

## 7. 扩展功能建议

### 7.1 未来可能的功能
- 支持多种颜色绘制
- 支持橡皮擦功能
- 支持撤销/重做操作
- 支持导入现有图片
- 支持图片预览和编辑
- 支持分享功能
- 支持批量处理

### 7.2 性能优化方向
- 使用Web Workers处理图片导出
- 实现图片压缩算法
- 优化Canvas绘制性能
- 实现懒加载图片夹